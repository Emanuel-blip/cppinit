#!/usr/bin/env bash

# === SHELL LIBRARY GUARD ===
# Prevent this file from being sourced multiple times
if [[ -n "${CPPINIT_MAKEFILE_LOADED:-}" ]]; then
    return 0
fi
readonly CPPINIT_MAKEFILE_LOADED=true

# lib/generators/makefile.sh - Generates Makefile for cppinit

# Source necessary utilities and config
source "$(dirname "${BASH_SOURCE[0]}")/../helpers/utils.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/config.sh"

# Generate Makefile
generate_makefile() {
    if [[ "$FLAG_INIT_ONLY" == true ]]; then
        return
    fi
    
    local file="$PROJECT_ROOT/Makefile"
    
    if [[ "$FLAG_DRY_RUN" == true ]]; then
        print_warning "DRY RUN: Would create Makefile"
        return
    fi
    
    local debug_flags="-g -Wall -Wextra -Wpedantic -std=c++17"
    local release_flags="-O2 -DNDEBUG -std=c++17"
    local current_flags
    
    if [[ "$BUILD_MODE" == "Release" ]]; then
        current_flags="$release_flags"
    else
        current_flags="$debug_flags"
    fi
    
    # --- 1. Main Makefile (uses unquoted EOF to allow variable expansion) ---
    # The variables PROJECT_NAME, SCRIPT_VERSION, and current_flags are expanded here.
    cat > "$file" << EOF
# Makefile for ${PROJECT_NAME}
# Generated by cppinit v${SCRIPT_VERSION}

# Project configuration
PROJECT_NAME = ${PROJECT_NAME}
CXX = g++
CXXFLAGS_DEBUG = ${debug_flags}
CXXFLAGS_RELEASE = ${release_flags}
CXXFLAGS = ${current_flags}

# Directories
SRC_DIR = src
INCLUDE_DIR = include
BUILD_DIR = build
BIN_DIR = bin
TEST_DIR = tests
DOC_DIR = docs

# Files
SOURCES = \$(wildcard \$(SRC_DIR)/*.cpp)
OBJECTS = \$(SOURCES:\$(SRC_DIR)/%.cpp=\$(BUILD_DIR)/%.o)
TARGET = \$(BIN_DIR)/\$(PROJECT_NAME)
TEST_SOURCES = \$(wildcard \$(TEST_DIR)/*.cpp)
TEST_OBJECTS = \$(TEST_SOURCES:\$(TEST_DIR)/%.cpp=\$(BUILD_DIR)/%.o)
TEST_TARGET = \$(BIN_DIR)/test_\$(PROJECT_NAME)

# Default target
.PHONY: all
all: build

# Build the main project
.PHONY: build
build: \$(TARGET)

\$(TARGET): \$(OBJECTS) | \$(BIN_DIR)
    @echo "ðŸ”— Linking \$(TARGET)..."
    @\$(CXX) \$(OBJECTS) -o \$@
    @echo "âœ… Build complete: \$(TARGET)"

\$(BUILD_DIR)/%.o: \$(SRC_DIR)/%.cpp | \$(BUILD_DIR)
    @echo "ðŸ”¨ Compiling \$<..."
    @\$(CXX) \$(CXXFLAGS) -I\$(INCLUDE_DIR) -c \$< -o \$@

# Create directories
\$(BUILD_DIR):
    @mkdir -p \$(BUILD_DIR)

\$(BIN_DIR):
    @mkdir -p \$(BIN_DIR)

# Clean build artifacts
.PHONY: clean
clean:
    @echo "ðŸ§¹ Cleaning build artifacts..."
    @rm -rf \$(BUILD_DIR)/* \$(BIN_DIR)/*
    @echo "âœ… Clean complete"

# Run the program
.PHONY: run
run: build
    @echo "ðŸš€ Running \$(PROJECT_NAME)..."
    @./\$(TARGET)

# Debug build
.PHONY: debug
debug:
    @echo "ðŸ› Building in debug mode..."
    @\$(MAKE) build CXXFLAGS="\$(CXXFLAGS_DEBUG)"

# Release build
.PHONY: release
release:
    @echo "ðŸš€ Building in release mode..."
    @\$(MAKE) build CXXFLAGS="\$(CXXFLAGS_RELEASE)"

EOF

    # --- 2. Test Targets (uses quoted 'EOF' to prevent shell interpretation of Makefile variables) ---
    if [[ "$FLAG_MINIMAL" != true ]]; then
        cat >> "$file" << 'EOF'
# Build and run tests
.PHONY: test
test: $(TEST_TARGET)
    @echo "ðŸ§ª Running tests..."
    @./$(TEST_TARGET)

$(TEST_TARGET): $(TEST_OBJECTS) $(filter-out $(BUILD_DIR)/main.o,$(OBJECTS)) | $(BIN_DIR)
    @echo "ðŸ”— Linking test executable..."
    @$(CXX) $^ -o $@

$(BUILD_DIR)/%.o: $(TEST_DIR)/%.cpp | $(BUILD_DIR)
    @echo "ðŸ”¨ Compiling test $<..."
    @$(CXX) $(CXXFLAGS) -I$(INCLUDE_DIR) -c $< -o $@

EOF
    fi
    
    # --- 3. Documentation, Install, and Help Targets ---
    cat >> "$file" << 'EOF'
# Generate documentation (requires Doxygen)
.PHONY: docs
docs:
    @if command -v doxygen >/dev/null 2>&1; then \
        echo "ðŸ“š Generating documentation..."; \
        doxygen Doxyfile 2>/dev/null || echo "âš ï¸  Doxyfile not found. Skipping documentation."; \
    else \
        echo "âš ï¸  Doxygen not found. Install it to generate documentation."; \
    fi

# Install the binary (requires sudo)
.PHONY: install
install: build
    @echo "ðŸ“¦ Installing $(PROJECT_NAME)..."
    @sudo cp $(TARGET) /usr/local/bin/
    @echo "âœ… $(PROJECT_NAME) installed to /usr/local/bin/"

# Uninstall the binary (requires sudo)
.PHONY: uninstall
uninstall:
    @echo "ðŸ—‘ï¸  Uninstalling $(PROJECT_NAME)..."
    @sudo rm -f /usr/local/bin/$(PROJECT_NAME)
    @echo "âœ… $(PROJECT_NAME) uninstalled"

# Check environment and dependencies
.PHONY: check
check:
    @echo "ðŸ” Checking build environment..."
    @echo "CXX: $(CXX)"
    @$(CXX) --version | head -n1
    @echo "CXXFLAGS: $(CXXFLAGS)"
    @echo "Project: $(PROJECT_NAME)"
    @echo "âœ… Environment check complete"

# Show help
.PHONY: help
help:
    @echo "ðŸ“– Available targets for $(PROJECT_NAME):"
    @echo ""
    @echo "  build    - Compile the project (default)"
    @echo "  clean    - Remove build artifacts"
    @echo "  run      - Build and execute the program"
    @echo "  debug    - Build with debug flags"
    @echo "  release  - Build with release flags"
EOF

    # --- 4. Append 'test' help if not minimal ---
    if [[ "$FLAG_MINIMAL" != true ]]; then
        cat >> "$file" << 'EOF'
    @echo "  test     - Build and run tests"
EOF
    fi
    
    # --- 5. Final Help Lines ---
    cat >> "$file" << 'EOF'
    @echo "  docs     - Generate documentation (requires Doxygen)"
    @echo "  install  - Install binary to /usr/local/bin (requires sudo)"
    @echo "  uninstall- Remove binary from /usr/local/bin (requires sudo)"
    @echo "  check    - Check build environment"
    @echo "  help     - Show this help message"
    @echo ""
    @echo "Examples:"
    @echo "  make build && make run"
    @echo "  make clean && make release"
EOF

    if [[ "$FLAG_MINIMAL" != true ]]; then
        cat >> "$file" << 'EOF'
    @echo "  make test"
EOF
    fi
    
    print_success "Generated Makefile"
    print_verbose "Makefile created with comprehensive build system"
}

